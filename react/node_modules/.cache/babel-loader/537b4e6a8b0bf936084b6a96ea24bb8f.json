{"ast":null,"code":"/*jslint browser:true, devel:true, white:true, vars:true */\n\n/*global require*/\n// hammer JS for touch support\nvar Hammer = require('hammerjs');\n\nHammer = typeof Hammer === 'function' ? Hammer : window.Hammer; // Get the chart variable\n\nvar Chart = require('chart.js');\n\nChart = typeof Chart === 'function' ? Chart : window.Chart;\nvar helpers = Chart.helpers; // Take the zoom namespace of Chart\n\nvar zoomNS = Chart.Zoom = Chart.Zoom || {}; // Where we store functions to handle different scale types\n\nvar zoomFunctions = zoomNS.zoomFunctions = zoomNS.zoomFunctions || {};\nvar panFunctions = zoomNS.panFunctions = zoomNS.panFunctions || {}; // Default options if none are provided\n\nvar defaultOptions = zoomNS.defaults = {\n  pan: {\n    enabled: true,\n    mode: 'xy',\n    speed: 20,\n    threshold: 10\n  },\n  zoom: {\n    enabled: true,\n    mode: 'xy',\n    sensitivity: 3\n  }\n};\n\nfunction directionEnabled(mode, dir) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n\nfunction rangeMaxLimiter(zoomPanOptions, newMax) {\n  if (zoomPanOptions.scaleAxes && zoomPanOptions.rangeMax && !helpers.isNullOrUndef(zoomPanOptions.rangeMax[zoomPanOptions.scaleAxes])) {\n    var rangeMax = zoomPanOptions.rangeMax[zoomPanOptions.scaleAxes];\n\n    if (newMax > rangeMax) {\n      newMax = rangeMax;\n    }\n  }\n\n  return newMax;\n}\n\nfunction rangeMinLimiter(zoomPanOptions, newMin) {\n  if (zoomPanOptions.scaleAxes && zoomPanOptions.rangeMin && !helpers.isNullOrUndef(zoomPanOptions.rangeMin[zoomPanOptions.scaleAxes])) {\n    var rangeMin = zoomPanOptions.rangeMin[zoomPanOptions.scaleAxes];\n\n    if (newMin < rangeMin) {\n      newMin = rangeMin;\n    }\n  }\n\n  return newMin;\n}\n\nfunction zoomIndexScale(scale, zoom, center, zoomOptions) {\n  var labels = scale.chart.data.labels;\n  var minIndex = scale.minIndex;\n  var lastLabelIndex = labels.length - 1;\n  var maxIndex = scale.maxIndex;\n  var sensitivity = zoomOptions.sensitivity;\n  var chartCenter = scale.isHorizontal() ? scale.left + scale.width / 2 : scale.top + scale.height / 2;\n  var centerPointer = scale.isHorizontal() ? center.x : center.y;\n  zoomNS.zoomCumulativeDelta = zoom > 1 ? zoomNS.zoomCumulativeDelta + 1 : zoomNS.zoomCumulativeDelta - 1;\n\n  if (Math.abs(zoomNS.zoomCumulativeDelta) > sensitivity) {\n    if (zoomNS.zoomCumulativeDelta < 0) {\n      if (centerPointer >= chartCenter) {\n        if (minIndex <= 0) {\n          maxIndex = Math.min(lastLabelIndex, maxIndex + 1);\n        } else {\n          minIndex = Math.max(0, minIndex - 1);\n        }\n      } else if (centerPointer < chartCenter) {\n        if (maxIndex >= lastLabelIndex) {\n          minIndex = Math.max(0, minIndex - 1);\n        } else {\n          maxIndex = Math.min(lastLabelIndex, maxIndex + 1);\n        }\n      }\n\n      zoomNS.zoomCumulativeDelta = 0;\n    } else if (zoomNS.zoomCumulativeDelta > 0) {\n      if (centerPointer >= chartCenter) {\n        minIndex = minIndex < maxIndex ? minIndex = Math.min(maxIndex, minIndex + 1) : minIndex;\n      } else if (centerPointer < chartCenter) {\n        maxIndex = maxIndex > minIndex ? maxIndex = Math.max(minIndex, maxIndex - 1) : maxIndex;\n      }\n\n      zoomNS.zoomCumulativeDelta = 0;\n    }\n\n    scale.options.ticks.min = rangeMinLimiter(zoomOptions, labels[minIndex]);\n    scale.options.ticks.max = rangeMaxLimiter(zoomOptions, labels[maxIndex]);\n  }\n}\n\nfunction zoomTimeScale(scale, zoom, center, zoomOptions) {\n  var options = scale.options;\n  var range;\n  var min_percent;\n\n  if (scale.isHorizontal()) {\n    range = scale.right - scale.left;\n    min_percent = (center.x - scale.left) / range;\n  } else {\n    range = scale.bottom - scale.top;\n    min_percent = (center.y - scale.top) / range;\n  }\n\n  var max_percent = 1 - min_percent;\n  var newDiff = range * (zoom - 1);\n  var minDelta = newDiff * min_percent;\n  var maxDelta = newDiff * max_percent;\n  var newMin = scale.getValueForPixel(scale.getPixelForValue(scale.min) + minDelta);\n  var newMax = scale.getValueForPixel(scale.getPixelForValue(scale.max) - maxDelta);\n  var diffMinMax = newMax.diff(newMin);\n  var minLimitExceeded = rangeMinLimiter(zoomOptions, diffMinMax) != diffMinMax;\n  var maxLimitExceeded = rangeMaxLimiter(zoomOptions, diffMinMax) != diffMinMax;\n\n  if (!minLimitExceeded && !maxLimitExceeded) {\n    options.time.min = newMin;\n    options.time.max = newMax;\n  }\n}\n\nfunction zoomNumericalScale(scale, zoom, center, zoomOptions) {\n  var range = scale.max - scale.min;\n  var newDiff = range * (zoom - 1);\n  var cursorPixel = scale.isHorizontal() ? center.x : center.y;\n  var min_percent = (scale.getValueForPixel(cursorPixel) - scale.min) / range;\n  var max_percent = 1 - min_percent;\n  var minDelta = newDiff * min_percent;\n  var maxDelta = newDiff * max_percent;\n  scale.options.ticks.min = rangeMinLimiter(zoomOptions, scale.min + minDelta);\n  scale.options.ticks.max = rangeMaxLimiter(zoomOptions, scale.max - maxDelta);\n}\n\nfunction zoomScale(scale, zoom, center, zoomOptions) {\n  var fn = zoomFunctions[scale.options.type];\n\n  if (fn) {\n    fn(scale, zoom, center, zoomOptions);\n  }\n}\n\nfunction doZoom(chartInstance, zoom, center, whichAxes) {\n  var ca = chartInstance.chartArea;\n\n  if (!center) {\n    center = {\n      x: (ca.left + ca.right) / 2,\n      y: (ca.top + ca.bottom) / 2\n    };\n  }\n\n  var zoomOptions = chartInstance.options.zoom;\n\n  if (zoomOptions && helpers.getValueOrDefault(zoomOptions.enabled, defaultOptions.zoom.enabled)) {\n    // Do the zoom here\n    var zoomMode = helpers.getValueOrDefault(chartInstance.options.zoom.mode, defaultOptions.zoom.mode);\n    zoomOptions.sensitivity = helpers.getValueOrDefault(chartInstance.options.zoom.sensitivity, defaultOptions.zoom.sensitivity); // Which axe should be modified when figers were used.\n\n    var _whichAxes;\n\n    if (zoomMode == 'xy' && whichAxes !== undefined) {\n      // based on fingers positions\n      _whichAxes = whichAxes;\n    } else {\n      // no effect\n      _whichAxes = 'xy';\n    }\n\n    helpers.each(chartInstance.scales, function (scale, id) {\n      if (scale.isHorizontal() && directionEnabled(zoomMode, 'x') && directionEnabled(_whichAxes, 'x')) {\n        zoomOptions.scaleAxes = \"x\";\n        zoomScale(scale, zoom, center, zoomOptions);\n      } else if (!scale.isHorizontal() && directionEnabled(zoomMode, 'y') && directionEnabled(_whichAxes, 'y')) {\n        // Do Y zoom\n        zoomOptions.scaleAxes = \"y\";\n        zoomScale(scale, zoom, center, zoomOptions);\n      }\n    });\n    chartInstance.update(0);\n\n    if (typeof zoomOptions.onZoom === 'function') {\n      zoomOptions.onZoom();\n    }\n  }\n}\n\nfunction panIndexScale(scale, delta, panOptions) {\n  var labels = scale.chart.data.labels;\n  var lastLabelIndex = labels.length - 1;\n  var offsetAmt = Math.max(scale.ticks.length - (scale.options.gridLines.offsetGridLines ? 0 : 1), 1);\n  var panSpeed = panOptions.speed;\n  var minIndex = scale.minIndex;\n  var step = Math.round(scale.width / (offsetAmt * panSpeed));\n  var maxIndex;\n  zoomNS.panCumulativeDelta += delta;\n  minIndex = zoomNS.panCumulativeDelta > step ? Math.max(0, minIndex - 1) : zoomNS.panCumulativeDelta < -step ? Math.min(lastLabelIndex - offsetAmt + 1, minIndex + 1) : minIndex;\n  zoomNS.panCumulativeDelta = minIndex !== scale.minIndex ? 0 : zoomNS.panCumulativeDelta;\n  maxIndex = Math.min(lastLabelIndex, minIndex + offsetAmt - 1);\n  scale.options.ticks.min = rangeMinLimiter(panOptions, labels[minIndex]);\n  scale.options.ticks.max = rangeMaxLimiter(panOptions, labels[maxIndex]);\n}\n\nfunction panTimeScale(scale, delta, panOptions) {\n  var options = scale.options;\n  var limitedMax = rangeMaxLimiter(panOptions, scale.getValueForPixel(scale.getPixelForValue(scale.max) - delta));\n  var limitedMin = rangeMinLimiter(panOptions, scale.getValueForPixel(scale.getPixelForValue(scale.min) - delta));\n  var limitedTimeDelta = delta < 0 ? limitedMax - scale.max : limitedMin - scale.min;\n  options.time.max = scale.max + limitedTimeDelta;\n  options.time.min = scale.min + limitedTimeDelta;\n}\n\nfunction panNumericalScale(scale, delta, panOptions) {\n  var tickOpts = scale.options.ticks;\n  var start = scale.start,\n      end = scale.end;\n\n  if (tickOpts.reverse) {\n    tickOpts.max = scale.getValueForPixel(scale.getPixelForValue(start) - delta);\n    tickOpts.min = scale.getValueForPixel(scale.getPixelForValue(end) - delta);\n  } else {\n    tickOpts.min = scale.getValueForPixel(scale.getPixelForValue(start) - delta);\n    tickOpts.max = scale.getValueForPixel(scale.getPixelForValue(end) - delta);\n  }\n\n  tickOpts.min = rangeMinLimiter(panOptions, tickOpts.min);\n  tickOpts.max = rangeMaxLimiter(panOptions, tickOpts.max);\n}\n\nfunction panScale(scale, delta, panOptions) {\n  var fn = panFunctions[scale.options.type];\n\n  if (fn) {\n    fn(scale, delta, panOptions);\n  }\n}\n\nfunction doPan(chartInstance, deltaX, deltaY) {\n  var panOptions = chartInstance.options.pan;\n\n  if (panOptions && helpers.getValueOrDefault(panOptions.enabled, defaultOptions.pan.enabled)) {\n    var panMode = helpers.getValueOrDefault(chartInstance.options.pan.mode, defaultOptions.pan.mode);\n    panOptions.speed = helpers.getValueOrDefault(chartInstance.options.pan.speed, defaultOptions.pan.speed);\n    helpers.each(chartInstance.scales, function (scale, id) {\n      if (scale.isHorizontal() && directionEnabled(panMode, 'x') && deltaX !== 0) {\n        panOptions.scaleAxes = \"x\";\n        panScale(scale, deltaX, panOptions);\n      } else if (!scale.isHorizontal() && directionEnabled(panMode, 'y') && deltaY !== 0) {\n        panOptions.scaleAxes = \"y\";\n        panScale(scale, deltaY, panOptions);\n      }\n    });\n    chartInstance.update(0);\n\n    if (typeof panOptions.onPan === 'function') {\n      panOptions.onPan();\n    }\n  }\n}\n\nfunction positionInChartArea(chartInstance, position) {\n  return position.x >= chartInstance.chartArea.left && position.x <= chartInstance.chartArea.right && position.y >= chartInstance.chartArea.top && position.y <= chartInstance.chartArea.bottom;\n}\n\nfunction getYAxis(chartInstance) {\n  var scales = chartInstance.scales;\n\n  for (var scaleId in scales) {\n    var scale = scales[scaleId];\n\n    if (!scale.isHorizontal()) {\n      return scale;\n    }\n  }\n} // Store these for later\n\n\nzoomNS.zoomFunctions.category = zoomIndexScale;\nzoomNS.zoomFunctions.time = zoomTimeScale;\nzoomNS.zoomFunctions.linear = zoomNumericalScale;\nzoomNS.zoomFunctions.logarithmic = zoomNumericalScale;\nzoomNS.panFunctions.category = panIndexScale;\nzoomNS.panFunctions.time = panTimeScale;\nzoomNS.panFunctions.linear = panNumericalScale;\nzoomNS.panFunctions.logarithmic = panNumericalScale; // Globals for catergory pan and zoom\n\nzoomNS.panCumulativeDelta = 0;\nzoomNS.zoomCumulativeDelta = 0; // Chartjs Zoom Plugin\n\nvar zoomPlugin = {\n  id: 'zoom',\n  afterInit: function afterInit(chartInstance) {\n    helpers.each(chartInstance.scales, function (scale) {\n      scale.originalOptions = helpers.clone(scale.options);\n    });\n\n    chartInstance.resetZoom = function () {\n      helpers.each(chartInstance.scales, function (scale, id) {\n        var timeOptions = scale.options.time;\n        var tickOptions = scale.options.ticks;\n\n        if (timeOptions) {\n          timeOptions.min = scale.originalOptions.time.min;\n          timeOptions.max = scale.originalOptions.time.max;\n        }\n\n        if (tickOptions) {\n          tickOptions.min = scale.originalOptions.ticks.min;\n          tickOptions.max = scale.originalOptions.ticks.max;\n        }\n      });\n      helpers.each(chartInstance.data.datasets, function (dataset, id) {\n        dataset._meta = null;\n      });\n      chartInstance.update();\n    };\n  },\n  beforeInit: function beforeInit(chartInstance) {\n    chartInstance.zoom = {};\n    var node = chartInstance.zoom.node = chartInstance.chart.ctx.canvas;\n    var options = chartInstance.options;\n    var panThreshold = helpers.getValueOrDefault(options.pan ? options.pan.threshold : undefined, zoomNS.defaults.pan.threshold);\n\n    if (!options.zoom || !options.zoom.enabled) {\n      return;\n    }\n\n    if (options.zoom.drag) {\n      // Only want to zoom horizontal axis\n      options.zoom.mode = 'x';\n\n      chartInstance.zoom._mouseDownHandler = function (event) {\n        chartInstance.zoom._dragZoomStart = event;\n      };\n\n      node.addEventListener('mousedown', chartInstance.zoom._mouseDownHandler);\n\n      chartInstance.zoom._mouseMoveHandler = function (event) {\n        if (chartInstance.zoom._dragZoomStart) {\n          chartInstance.zoom._dragZoomEnd = event;\n          chartInstance.update(0);\n        }\n      };\n\n      node.addEventListener('mousemove', chartInstance.zoom._mouseMoveHandler);\n\n      chartInstance.zoom._mouseUpHandler = function (event) {\n        if (chartInstance.zoom._dragZoomStart) {\n          var chartArea = chartInstance.chartArea;\n          var yAxis = getYAxis(chartInstance);\n          var beginPoint = chartInstance.zoom._dragZoomStart;\n          var offsetX = beginPoint.target.getBoundingClientRect().left;\n          var startX = Math.min(beginPoint.clientX, event.clientX) - offsetX;\n          var endX = Math.max(beginPoint.clientX, event.clientX) - offsetX;\n          var dragDistance = endX - startX;\n          var chartDistance = chartArea.right - chartArea.left;\n          var zoom = 1 + (chartDistance - dragDistance) / chartDistance; // Remove drag start and end before chart update to stop drawing selected area\n\n          chartInstance.zoom._dragZoomStart = null;\n          chartInstance.zoom._dragZoomEnd = null;\n\n          if (dragDistance > 0) {\n            doZoom(chartInstance, zoom, {\n              x: dragDistance / 2 + startX,\n              y: (yAxis.bottom - yAxis.top) / 2\n            });\n          }\n        }\n      };\n\n      node.addEventListener('mouseup', chartInstance.zoom._mouseUpHandler);\n    } else {\n      chartInstance.zoom._wheelHandler = function (event) {\n        var rect = event.target.getBoundingClientRect();\n        var offsetX = event.clientX - rect.left;\n        var offsetY = event.clientY - rect.top;\n        var center = {\n          x: offsetX,\n          y: offsetY\n        };\n\n        if (event.deltaY < 0) {\n          doZoom(chartInstance, 1.1, center);\n        } else {\n          doZoom(chartInstance, 0.909, center);\n        } // Prevent the event from triggering the default behavior (eg. Content scrolling).\n\n\n        event.preventDefault();\n      };\n\n      node.addEventListener('wheel', chartInstance.zoom._wheelHandler);\n    }\n\n    if (Hammer) {\n      var mc = new Hammer.Manager(node);\n      mc.add(new Hammer.Pinch());\n      mc.add(new Hammer.Pan({\n        threshold: panThreshold\n      })); // Hammer reports the total scaling. We need the incremental amount\n\n      var currentPinchScaling;\n\n      var handlePinch = function handlePinch(e) {\n        var diff = 1 / currentPinchScaling * e.scale;\n        var rect = e.target.getBoundingClientRect();\n        var offsetX = e.center.x - rect.left;\n        var offsetY = e.center.y - rect.top;\n        var center = {\n          x: offsetX,\n          y: offsetY\n        }; // fingers position difference\n\n        var x = Math.abs(e.pointers[0].clientX - e.pointers[1].clientX);\n        var y = Math.abs(e.pointers[0].clientY - e.pointers[1].clientY); // diagonal fingers will change both (xy) axes\n\n        var p = x / y;\n        var xy;\n\n        if (p > 0.3 && p < 1.7) {\n          xy = 'xy';\n        } // x axis\n        else if (x > y) {\n            xy = 'x';\n          } // y axis\n          else {\n              xy = 'y';\n            }\n\n        doZoom(chartInstance, diff, center, xy); // Keep track of overall scale\n\n        currentPinchScaling = e.scale;\n      };\n\n      mc.on('pinchstart', function (e) {\n        currentPinchScaling = 1; // reset tracker\n      });\n      mc.on('pinch', handlePinch);\n      mc.on('pinchend', function (e) {\n        handlePinch(e);\n        currentPinchScaling = null; // reset\n\n        zoomNS.zoomCumulativeDelta = 0;\n      });\n      var currentDeltaX = null,\n          currentDeltaY = null,\n          panning = false;\n\n      var handlePan = function handlePan(e) {\n        if (currentDeltaX !== null && currentDeltaY !== null) {\n          panning = true;\n          var deltaX = e.deltaX - currentDeltaX;\n          var deltaY = e.deltaY - currentDeltaY;\n          currentDeltaX = e.deltaX;\n          currentDeltaY = e.deltaY;\n          doPan(chartInstance, deltaX, deltaY);\n        }\n      };\n\n      mc.on('panstart', function (e) {\n        currentDeltaX = 0;\n        currentDeltaY = 0;\n        handlePan(e);\n      });\n      mc.on('panmove', handlePan);\n      mc.on('panend', function (e) {\n        currentDeltaX = null;\n        currentDeltaY = null;\n        zoomNS.panCumulativeDelta = 0;\n        setTimeout(function () {\n          panning = false;\n        }, 500);\n      });\n\n      chartInstance.zoom._ghostClickHandler = function (e) {\n        if (panning) {\n          e.stopImmediatePropagation();\n          e.preventDefault();\n        }\n      };\n\n      node.addEventListener('click', chartInstance.zoom._ghostClickHandler);\n      chartInstance._mc = mc;\n    }\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(chartInstance) {\n    var ctx = chartInstance.chart.ctx;\n    var chartArea = chartInstance.chartArea;\n    ctx.save();\n    ctx.beginPath();\n\n    if (chartInstance.zoom._dragZoomEnd) {\n      var yAxis = getYAxis(chartInstance);\n      var beginPoint = chartInstance.zoom._dragZoomStart;\n      var endPoint = chartInstance.zoom._dragZoomEnd;\n      var offsetX = beginPoint.target.getBoundingClientRect().left;\n      var startX = Math.min(beginPoint.clientX, endPoint.clientX) - offsetX;\n      var endX = Math.max(beginPoint.clientX, endPoint.clientX) - offsetX;\n      var rectWidth = endX - startX;\n      ctx.fillStyle = 'rgba(225,225,225,0.3)';\n      ctx.lineWidth = 5;\n      ctx.fillRect(startX, yAxis.top, rectWidth, yAxis.bottom - yAxis.top);\n    }\n\n    ctx.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    ctx.clip();\n  },\n  afterDatasetsDraw: function afterDatasetsDraw(chartInstance) {\n    chartInstance.chart.ctx.restore();\n  },\n  destroy: function destroy(chartInstance) {\n    if (chartInstance.zoom) {\n      var options = chartInstance.options;\n      var node = chartInstance.zoom.node;\n\n      if (options.zoom && options.zoom.drag) {\n        node.removeEventListener('mousedown', chartInstance.zoom._mouseDownHandler);\n        node.removeEventListener('mousemove', chartInstance.zoom._mouseMoveHandler);\n        node.removeEventListener('mouseup', chartInstance.zoom._mouseUpHandler);\n      } else {\n        node.removeEventListener('wheel', chartInstance.zoom._wheelHandler);\n      }\n\n      if (Hammer) {\n        node.removeEventListener('click', chartInstance.zoom._ghostClickHandler);\n      }\n\n      delete chartInstance.zoom;\n      var mc = chartInstance._mc;\n\n      if (mc) {\n        mc.remove('pinchstart');\n        mc.remove('pinch');\n        mc.remove('pinchend');\n        mc.remove('panstart');\n        mc.remove('pan');\n        mc.remove('panend');\n      }\n    }\n  }\n};\nmodule.exports = zoomPlugin;\nChart.pluginService.register(zoomPlugin);","map":null,"metadata":{},"sourceType":"script"}